}
# Retorna una lista con el gráfico y la potencia calculada
return(list(plot=plot, power=Power))
}
# Plot de gráfico de potencia
# Experimentos
# Ejemplo 1: One-sample test, variando la media poblacional y alfa
mu_vals <- seq(90, 110, by=1)
powers <- sapply(mu_vals, function(mu.True) {
result <- power.z.test(n1=16, sigma1=16, mu.Ha=100, mu.True=mu.True, alfa=0.05)
return(result$power)
})
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
install.packages('scatterplot3d')
library(scatterplot3d)
library(ggplot2)
library(plotly)
# Manipulación de varios plots en una imagen.
library(gridExtra)
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
library(ggplot2)
library(plotly)
# Manipulación de varios plots en una imagen.
library(gridExtra)
# Power Function, El esqueleto posee como ejemplo como obtener la potencia de un z-test one-sample.
# Si utiliza este esqueleto deberá comentar la función que cumple cada una de las partes entregadas
power.z.test <- function(n1=NULL, sigma1=0.5,
n2=NULL,sigma2=0.5, mu.Ha=0 ,
mu.True=0, alfa=0.05){
if(is.null(n2)){
# Z crítico para cola derecha (one-sided)
Z = qnorm(1-alfa)
denominador = sigma1/sqrt(n1)
X_bar = Z*denominador + mu.Ha
numerador = X_bar - mu.True
Z = numerador/denominador
Power = 1 - pnorm(Z)
# Generación del gráfico con ggplot2
min_lim = min(rnorm(1000, mean=mu.Ha, sd=denominador)) -
round(min(rnorm(1000, mean=mu.Ha, sd=denominador)))%%10
max_lim = max(rnorm(1000, mean=mu.True, sd=denominador)) +
round(max(rnorm(1000, mean=mu.True, sd=denominador)))%%10
plot <- ggplot(data.frame(x = c(min_lim, max_lim)), aes(x)) +
stat_function(fun = dnorm, args = list(mean = mu.Ha, sd = denominador),
col='red') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominador),
col='blue') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominador),
xlim = c(X_bar,max_lim), geom = "area", fill='red') +
geom_vline(xintercept = X_bar, linetype="dotted", size=1) +
annotate(x=X_bar, y=+Inf,label="alpha", vjust=2, geom="label") +
theme_minimal() +
ggtitle("H0 vs Ha") +
xlab(expression(bar(X))) + ylab("Density")
}else {
# Condición para Two-Sample Z-test (n2 no es nulo)
Z_crit = qnorm(1 - alfa)
# Cálculo de la desviación estándar combinada
denominator = sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
X_bar = Z_crit * denominator + mu.Ha
# Cálculo del Z bajo la hipótesis alternativa
numerator = X_bar - mu.True
Z_alt = numerator / denominator
Power = 1 - pnorm(Z_alt)
# Generación del gráfico para Two-Sample Z-test
min_lim = min(rnorm(1000, mean=mu.Ha, sd=denominator)) - 10
max_lim = max(rnorm(1000, mean=mu.True, sd=denominator)) + 10
plot <- ggplot(data.frame(x = c(min_lim, max_lim)), aes(x)) +
stat_function(fun = dnorm, args = list(mean = mu.Ha, sd = denominator), col='red') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominator), col='blue') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominator),
xlim = c(X_bar, max_lim), geom = "area", fill='red') +
geom_vline(xintercept = X_bar, linetype="dotted", size=1) +
annotate(x=X_bar, y=+Inf, label="alpha", vjust=2, geom="label") +
theme_minimal() +
ggtitle("H0 vs Ha - Two Sample") +
xlab(expression(bar(X))) + ylab("Density")
}
# Retorna una lista con el gráfico y la potencia calculada
return(list(plot=plot, power=Power))
}
# Plot de gráfico de potencia
# Experimentos
# Ejemplo 1: One-sample test, variando la media poblacional y alfa
mu_vals <- seq(90, 110, by=1)
powers <- sapply(mu_vals, function(mu.True) {
result <- power.z.test(n1=16, sigma1=16, mu.Ha=100, mu.True=mu.True, alfa=0.05)
return(result$power)
})
# Gráfico de la potencia vs mu.True
plot(mu_vals, powers, type='l', col='blue', main="Power vs mu.True (alfa = 0.05)",
xlab="Media de la Población", ylab="Potencia")
# Ejemplo 2: Two-sample test, variando la media poblacional y alfa
mu_vals <- seq(90, 110, by=1)
powers <- sapply(mu_vals, function(mu.True) {
result <- power.z.test(n1=16, sigma1=16, n2=16, sigma2=16, mu.Ha=100, mu.True=mu.True, alfa=0.05)
return(result$power)
})
# Gráfico de la potencia vs mu.True
plot(mu_vals, powers, type='l', col='red', main="Power vs mu.True (Two-Sample)",
xlab="Diferencia de Medias de la Población", ylab="Potencia")
# Power Function, El esqueleto posee como ejemplo como obtener la potencia de un z-test one-sample.
# Si utiliza este esqueleto deberá comentar la función que cumple cada una de las partes entregadas
power.z.test <- function(n1=NULL, sigma1=0.5,
n2=NULL,sigma2=0.5, mu.Ha=0 ,
mu.True=0, alfa=0.05){
if(is.null(n2)){
# Z crítico para cola derecha (one-sided)
Z = qnorm(1-alfa)
denominador = sigma1/sqrt(n1)
X_bar = Z*denominador + mu.Ha
numerador = X_bar - mu.True
Z = numerador/denominador
Power = 1 - pnorm(Z)
# Generación del gráfico con ggplot2
min_lim = min(rnorm(1000, mean=mu.Ha, sd=denominador)) -
round(min(rnorm(1000, mean=mu.Ha, sd=denominador)))%%10
max_lim = max(rnorm(1000, mean=mu.True, sd=denominador)) +
round(max(rnorm(1000, mean=mu.True, sd=denominador)))%%10
plot <- ggplot(data.frame(x = c(min_lim, max_lim)), aes(x)) +
stat_function(fun = dnorm, args = list(mean = mu.Ha, sd = denominador),
col='red') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominador),
col='blue') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominador),
xlim = c(X_bar,max_lim), geom = "area", fill='red') +
geom_vline(xintercept = X_bar, linetype="dotted", linewidth=1) +
annotate(x=X_bar, y=+Inf,label="alpha", vjust=2, geom="label") +
theme_minimal() +
ggtitle("H0 vs Ha") +
xlab(expression(bar(X))) + ylab("Density")
}else {
# Condición para Two-Sample Z-test (n2 no es nulo)
Z_crit = qnorm(1 - alfa)
# Cálculo de la desviación estándar combinada
denominator = sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
X_bar = Z_crit * denominator + mu.Ha
# Cálculo del Z bajo la hipótesis alternativa
numerator = X_bar - mu.True
Z_alt = numerator / denominator
Power = 1 - pnorm(Z_alt)
# Generación del gráfico para Two-Sample Z-test
min_lim = min(rnorm(1000, mean=mu.Ha, sd=denominator)) - 10
max_lim = max(rnorm(1000, mean=mu.True, sd=denominator)) + 10
plot <- ggplot(data.frame(x = c(min_lim, max_lim)), aes(x)) +
stat_function(fun = dnorm, args = list(mean = mu.Ha, sd = denominator), col='red') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominator), col='blue') +
stat_function(fun = dnorm, args = list(mean = mu.True, sd = denominator),
xlim = c(X_bar, max_lim), geom = "area", fill='red') +
geom_vline(xintercept = X_bar, linetype="dotted", linewidth=1) +
annotate(x=X_bar, y=+Inf, label="alpha", vjust=2, geom="label") +
theme_minimal() +
ggtitle("H0 vs Ha - Two Sample") +
xlab(expression(bar(X))) + ylab("Density")
}
# Retorna una lista con el gráfico y la potencia calculada
return(list(plot=plot, power=Power))
}
# Plot de gráfico de potencia
# Experimentos
# Ejemplo 1: One-sample test, variando la media poblacional y alfa
mu_vals <- seq(90, 110, by=1)
powers <- sapply(mu_vals, function(mu.True) {
result <- power.z.test(n1=16, sigma1=16, mu.Ha=100, mu.True=mu.True, alfa=0.05)
return(result$power)
})
# Gráfico de la potencia vs mu.True
plot(mu_vals, powers, type='l', col='blue', main="Power vs mu.True (alfa = 0.05)",
xlab="Media de la Población", ylab="Potencia")
# Ejemplo 2: Two-sample test, variando la media poblacional y alfa
mu_vals <- seq(90, 110, by=1)
powers <- sapply(mu_vals, function(mu.True) {
result <- power.z.test(n1=16, sigma1=16, n2=16, sigma2=16, mu.Ha=100, mu.True=mu.True, alfa=0.05)
return(result$power)
})
# Gráfico de la potencia vs mu.True
plot(mu_vals, powers, type='l', col='red', main="Power vs mu.True (Two-Sample)",
xlab="Diferencia de Medias de la Población", ylab="Potencia")
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
z_test_multiple <- function(data_list, sigma_list, alpha=0.05) {
results <- list()
m <- length(data_list) * (length(data_list) - 1) / 2  # Número de tests
index <- 1
for (i in 1:(length(data_list) - 1)) {
for (j in (i + 1):length(data_list)) {
test_result <- z_test(data_list[[i]], sigma_list[i], data2=data_list[[j]], sigma2=sigma_list[j])
test_result$p_value <- min(test_result$p_value * m, 1) # Corrección de Bonferroni
results[[index]] <- list(data1=i, data2=j, z_score=test_result$z_score, p_value=test_result$p_value)
index <- index + 1
}
}
return(results)
}
# Llamada a la función
results <- z_test_multiple(list(income_graduation, income_master, income_phd), c(28180, 20160, 20615))
# Definir parámetros conocidos
mu_Graduation <- 52000  # Valor para contrastar
sigma_Graduation <- 28180  # Desviación estándar estimada para Graduation
# Realizar el test one-sided (menor y mayor) y two-sided
result_one_sided_menor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='menor')
result_one_sided_mayor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='mayor')
result_two_sided <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='two-sided')
# Mostrar resultados
cat("One-sided test (menor): Z-score =", result_one_sided_menor$z_score, ", p-value =", result_one_sided_menor$p_value, "\n")
cat("One-sided test (mayor): Z-score =", result_one_sided_mayor$z_score, ", p-value =", result_one_sided_mayor$p_value, "\n")
cat("Two-sided test: Z-score =", result_two_sided$z_score, ", p-value =", result_two_sided$p_value, "\n")
# Desviaciones estándar de cada grupo
sigma_Graduation <- 28180
sigma_Master <- 20160
sigma_PhD <- 20615
# Realizar múltiples tests usando la función con corrección de Bonferroni
result_multiple_tests <- z_test_multiple(
data_list = list(income_graduation, income_master, income_phd),
sigma_list = c(sigma_Graduation, sigma_Master, sigma_PhD),
alpha = 0.05
)
# Mostrar resultados de los múltiples tests con corrección de Bonferroni
for (res in result_multiple_tests) {
cat("Comparación entre grupo", res$data1, "y grupo", res$data2, ": Z-score =", res$z_score, ", p-value ajustado =", res$p_value, "\n")
}
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
z_test_multiple <- function(data_list, sigma_list, alpha=0.05) {
results <- list()
m <- length(data_list) * (length(data_list) - 1) / 2  # Número de tests
index <- 1
for (i in 1:(length(data_list) - 1)) {
for (j in (i + 1):length(data_list)) {
test_result <- z_test(data_list[[i]], sigma_list[i], data2=data_list[[j]], sigma2=sigma_list[j])
test_result$p_value <- min(test_result$p_value * m, 1) # Corrección de Bonferroni
results[[index]] <- list(data1=i, data2=j, z_score=test_result$z_score, p_value=test_result$p_value)
index <- index + 1
}
}
return(results)
}
# Llamada a la función
results <- z_test_multiple(list(income_graduation, income_master, income_phd), c(28180, 20160, 20615))
z_test_multiple <- function(data_list, sigma_list, alpha=0.05) {
results <- list()
m <- length(data_list) * (length(data_list) - 1) / 2  # Número de tests
index <- 1
for (i in 1:(length(data_list) - 1)) {
for (j in (i + 1):length(data_list)) {
test_result <- z_test(data_list[[i]], sigma_list[i], data2=data_list[[j]], sigma2=sigma_list[j])
test_result$p_value <- min(test_result$p_value * m, 1) # Corrección de Bonferroni
results[[index]] <- list(data1=i, data2=j, z_score=test_result$z_score, p_value=test_result$p_value)
index <- index + 1
}
}
return(results)
}
# Llamada a la función
results <- z_test_multiple(list(income_graduation, income_master, income_phd), c(28180, 20160, 20615))
results
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
head(income_graduation)
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
head(income_master)
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
any(is.na(income_graduation))
any(is.na(income_master))
any(is.na(income_phd))
any(is.na(income_graduation))
any(is.na(income_master))
any(is.na(income_phd))
df = read.csv('marketing_campaign.csv', sep='\t')
head(df)
# Filtrar ingresos por grado académico
income_graduation <- df$Income[df$Education == 'Graduation']
income_master <- df$Income[df$Education == 'Master']
income_phd <- df$Income[df$Education == 'PhD']
# Remueve los valores NA de cada vector
income_graduation <- income_graduation[!is.na(income_graduation)]
income_master <- income_master[!is.na(income_master)]
income_phd <- income_phd[!is.na(income_phd)]
# Implementación de Z-test
z_test <- function(data1, sigma1, mu.Ha=0, data2=NULL, sigma2=NULL, test.type='two-sided') {
n1 <- length(data1)
mean1 <- mean(data1)
if (is.null(data2)) { # One-sample Z-test
z <- (mean1 - mu.Ha) / (sigma1 / sqrt(n1))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
} else { # Two-sample Z-test
n2 <- length(data2)
mean2 <- mean(data2)
z <- (mean2 - mean1 - mu.Ha) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
if (test.type == 'menor') p <- pnorm(z)
else if (test.type == 'mayor') p <- 1 - pnorm(z)
else p <- 2 * (1 - pnorm(abs(z)))
}
return(list(z_score=z, p_value=p))
}
z_test_multiple <- function(data_list, sigma_list, alpha=0.05) {
results <- list()
m <- length(data_list) * (length(data_list) - 1) / 2  # Número de tests
index <- 1
for (i in 1:(length(data_list) - 1)) {
for (j in (i + 1):length(data_list)) {
test_result <- z_test(data_list[[i]], sigma_list[i], data2=data_list[[j]], sigma2=sigma_list[j])
test_result$p_value <- min(test_result$p_value * m, 1) # Corrección de Bonferroni
results[[index]] <- list(data1=i, data2=j, z_score=test_result$z_score, p_value=test_result$p_value)
index <- index + 1
}
}
return(results)
}
# Llamada a la función
results <- z_test_multiple(list(income_graduation, income_master, income_phd), c(28180, 20160, 20615))
results
# Definir parámetros conocidos
mu_Graduation <- 52000  # Valor para contrastar
sigma_Graduation <- 28180  # Desviación estándar estimada para Graduation
# Realizar el test one-sided (menor y mayor) y two-sided
result_one_sided_menor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='menor')
result_one_sided_mayor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='mayor')
result_two_sided <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='two-sided')
# Mostrar resultados
cat("One-sided test (menor): Z-score =", result_one_sided_menor$z_score, ", p-value =", result_one_sided_menor$p_value, "\n")
cat("One-sided test (mayor): Z-score =", result_one_sided_mayor$z_score, ", p-value =", result_one_sided_mayor$p_value, "\n")
cat("Two-sided test: Z-score =", result_two_sided$z_score, ", p-value =", result_two_sided$p_value, "\n")
# Desviaciones estándar de cada grupo
sigma_Graduation <- 28180
sigma_Master <- 20160
sigma_PhD <- 20615
# Realizar múltiples tests usando la función con corrección de Bonferroni
result_multiple_tests <- z_test_multiple(
data_list = list(income_graduation, income_master, income_phd),
sigma_list = c(sigma_Graduation, sigma_Master, sigma_PhD),
alpha = 0.05
)
# Mostrar resultados de los múltiples tests con corrección de Bonferroni
for (res in result_multiple_tests) {
cat("Comparación entre grupo", res$data1, "y grupo", res$data2, ": Z-score =", res$z_score, ", p-value ajustado =", res$p_value, "\n")
}
z_test_multiple <- function(data_list, sigma_list, alpha=0.05) {
results <- list()
m <- length(data_list) * (length(data_list) - 1) / 2  # Número de tests
index <- 1
for (i in 1:(length(data_list) - 1)) {
for (j in (i + 1):length(data_list)) {
test_result <- z_test(data_list[[i]], sigma_list[i], data2=data_list[[j]], sigma2=sigma_list[j])
test_result$p_value <- min(test_result$p_value * m, 1) # Corrección de Bonferroni
results[[index]] <- list(data1=i, data2=j, z_score=test_result$z_score, p_value=test_result$p_value)
index <- index + 1
}
}
return(results)
}
# Definir parámetros conocidos
mu_Graduation <- 52000  # Valor para contrastar
sigma_Graduation <- 28180  # Desviación estándar estimada para Graduation
# Realizar el test one-sided (menor y mayor) y two-sided
result_one_sided_menor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='menor')
result_one_sided_mayor <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='mayor')
result_two_sided <- z_test(data1=income_graduation, sigma1=sigma_Graduation, mu.Ha=mu_Graduation, test.type='two-sided')
# Mostrar resultados
cat("One-sided test (menor): Z-score =", result_one_sided_menor$z_score, ", p-value =", result_one_sided_menor$p_value, "\n")
cat("One-sided test (mayor): Z-score =", result_one_sided_mayor$z_score, ", p-value =", result_one_sided_mayor$p_value, "\n")
cat("Two-sided test: Z-score =", result_two_sided$z_score, ", p-value =", result_two_sided$p_value, "\n")
# Desviaciones estándar de cada grupo
sigma_Graduation <- 28180
sigma_Master <- 20160
sigma_PhD <- 20615
# Realizar múltiples tests usando la función con corrección de Bonferroni
result_multiple_tests <- z_test_multiple(
data_list = list(income_graduation, income_master, income_phd),
sigma_list = c(sigma_Graduation, sigma_Master, sigma_PhD),
alpha = 0.05
)
# Mostrar resultados de los múltiples tests con corrección de Bonferroni
for (res in result_multiple_tests) {
cat("Comparación entre grupo", res$data1, "y grupo", res$data2, ": Z-score =", res$z_score, ", p-value ajustado =", res$p_value, "\n")
}
