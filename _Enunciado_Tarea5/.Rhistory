return(x^(alpha-1)*exp(-betha*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
proposal <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , proposal , current )
}
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-betha*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , proposal , current )
}
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , proposal , current )
}
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(theta[-1])
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
muestras <- vector(length = reps + 1)
current <- theta_0
for ( i in 1:reps +1) {
muestras[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = muestras[i], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(muestras[i], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(muestras[-1])
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6, 1e7)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i-1] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i-1] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
}
