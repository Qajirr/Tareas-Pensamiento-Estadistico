for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6, 1e7)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(1, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
hist(metropolis_hasting(1, 1e1, 5, 0.2))
hist(metropolis_hasting(1, 1e2, 5, 0.2))
hist(metropolis_hasting(1, 1e3, 5, 0.2))
hist(metropolis_hasting(1, 1e4, 5, 0.2))
hist(metropolis_hasting(1, 1e5, 5, 0.2))
hist(metropolis_hasting(1, 1e6, 5, 0.2))
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i-1] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
# Primeramente se define la función de densidad gamma
gamma_dens <- function(x, alpha, beta){
if(x > 0){
return(x^(alpha-1)*exp(-beta*x))
}
else{
return(0)
}
}
# Ahora se define el algoritmo de Metropolis Hasting con la función gamma anterior
metropolis_hasting <- function(theta_0, reps, alpha, beta){
thetas <- vector(length = reps )
current <- theta_0
for ( i in 2:reps ) {
thetas[i-1] <- current
# distribución propuesta
propuesta <- rnorm(1, mean = thetas[i-1], 1)
# densidad gamma de la distribución propuesta
gamma_propuesta <- gamma_dens(propuesta, alpha, beta)
# densidad gamma de la distribución actual
gamma_actual <- gamma_dens(thetas[i-1], alpha, beta)
# Calculo del ratio
ratio <- gamma_propuesta/gamma_actual
# Probabilidad de aceptar
prob <- min(ratio,1)
decision <- rbinom(1,1,prob)
current <- ifelse( decision == 1 , propuesta , current )
}
return(thetas)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
curve((x^(alpha - 1) * exp(-beta * x)) / gamma(alpha) / beta^alpha,
add = TRUE, col = "red", lwd = 2)
}
alpha <- 5
beta <- 1/5
beta_0 <- 1
iteraciones_list <- c(100, 1000, 10000, 1e5, 1e6)
par(mfrow = c(2, 2))
for (reps in iteraciones_list) {
muestras <- metropolis_hasting(beta_0, reps, alpha, beta)
hist(muestras, probability = TRUE, main = paste("Iteraciones:", reps),
xlab = "x", breaks = 50, col = "lightblue")
}
install.packages("dagitty")
library(dagitty)
---
![](banner.png)
---
![](banner.png)
<center>
# Cargar la librería
library(dagitty)
>
# Cargar la librería
library(dagitty)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educación -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Código para crear y analizar una DAG en R utilizando la librería dagitty
# Instalar el paquete dagitty si no está instalado
if (!requireNamespace("dagitty", quietly = TRUE)) {
install.packages("dagitty")
}
# Cargar la librería
library(dagitty)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educación -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Código para crear y analizar una DAG en R utilizando la librería dagitty
# Instalar el paquete dagitty si no está instalado
if (!requireNamespace("dagitty", quietly = TRUE)) {
install.packages("dagitty")
}
# Cargar la librería
library(dagitty)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Imprimir la DAG
print(dag)
# Visualizar las independencias condicionales
cat("\nIndependencias condicionales identificadas por la DAG:\n")
impliedConditionalIndependencies(dag)
# Visualización interactiva de la DAG
plot(dag)
# Explicación de las independencias condicionales:
cat("
Explicación con d-separación:
1. 'Educación ⊥ Esfuerzo | Ingresos':
- 'Ingresos' es un collider en el camino 'Educación -> Ingresos <- Esfuerzo'.
- Condicionar en 'Ingresos' bloquea la dependencia entre 'Educación' y 'Esfuerzo'.
2. 'Oportunidades ⊥ Educación | Inteligencia':
- 'Inteligencia' es un nodo de fork en el camino 'Educación <- Inteligencia -> Oportunidades'.
- Condicionar en 'Inteligencia' bloquea el flujo de información entre 'Oportunidades' y 'Educación'.
3. 'Oportunidades ⊥ Esfuerzo | Ingresos, Inteligencia':
- Condicionar en 'Inteligencia' bloquea la influencia desde 'Oportunidades' a 'Ingresos'.
- Además, 'Ingresos' como collider bloquea el camino hacia 'Esfuerzo'.
")
# Para generar una visualización más detallada, exportar el gráfico a una imagen:
library(ggdag)
# Código para crear y analizar una DAG en R utilizando la librería dagitty
# Instalar el paquete dagitty si no está instalado
if (!requireNamespace("ggdag", quietly = TRUE)) {
install.packages("ggdag")
}
# Cargar la librería
library(dagitty)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Imprimir la DAG
print(dag)
# Visualizar las independencias condicionales
cat("\nIndependencias condicionales identificadas por la DAG:\n")
impliedConditionalIndependencies(dag)
# Visualización interactiva de la DAG
plot(dag)
# Explicación de las independencias condicionales:
cat("
Explicación con d-separación:
1. 'Educación ⊥ Esfuerzo | Ingresos':
- 'Ingresos' es un collider en el camino 'Educación -> Ingresos <- Esfuerzo'.
- Condicionar en 'Ingresos' bloquea la dependencia entre 'Educación' y 'Esfuerzo'.
2. 'Oportunidades ⊥ Educación | Inteligencia':
- 'Inteligencia' es un nodo de fork en el camino 'Educación <- Inteligencia -> Oportunidades'.
- Condicionar en 'Inteligencia' bloquea el flujo de información entre 'Oportunidades' y 'Educación'.
3. 'Oportunidades ⊥ Esfuerzo | Ingresos, Inteligencia':
- Condicionar en 'Inteligencia' bloquea la influencia desde 'Oportunidades' a 'Ingresos'.
- Además, 'Ingresos' como collider bloquea el camino hacia 'Esfuerzo'.
")
# Para generar una visualización más detallada, exportar el gráfico a una imagen:
library(ggdag)
ggdag::ggdag(dag) +
ggtitle("Directed Acyclic Graph (DAG)") +
theme_dark()
# Cargar la librería
library(dagitty)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Imprimir la DAG
print(dag)
# Visualizar las independencias condicionales
cat("\nIndependencias condicionales identificadas por la DAG:\n")
impliedConditionalIndependencies(dag)
# Visualización interactiva de la DAG
plot(dag)
# Explicación de las independencias condicionales:
cat("
Explicación con d-separación:
1. 'Educación ⊥ Esfuerzo | Ingresos':
- 'Ingresos' es un collider en el camino 'Educación -> Ingresos <- Esfuerzo'.
- Condicionar en 'Ingresos' bloquea la dependencia entre 'Educación' y 'Esfuerzo'.
2. 'Oportunidades ⊥ Educación | Inteligencia':
- 'Inteligencia' es un nodo de fork en el camino 'Educación <- Inteligencia -> Oportunidades'.
- Condicionar en 'Inteligencia' bloquea el flujo de información entre 'Oportunidades' y 'Educación'.
3. 'Oportunidades ⊥ Esfuerzo | Ingresos, Inteligencia':
- Condicionar en 'Inteligencia' bloquea la influencia desde 'Oportunidades' a 'Ingresos'.
- Además, 'Ingresos' como collider bloquea el camino hacia 'Esfuerzo'.
")
# Para generar una visualización más detallada, exportar el gráfico a una imagen:
library(ggdag)
library(ggplot2)
ggdag::ggdag(dag) +
ggtitle("Directed Acyclic Graph (DAG)") +
theme_dark()
# Cargar la librería
library(dagitty)
library(ggdag)
library(ggplot2)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Imprimir la DAG
print(dag)
# Visualizar las independencias condicionales
cat("\nIndependencias condicionales identificadas por la DAG:\n")
impliedConditionalIndependencies(dag)
# Visualización interactiva de la DAG
plot(dag)
# Explicación de las independencias condicionales:
cat("
Explicación con d-separación:
1. 'Educación ⊥ Esfuerzo | Ingresos':
- 'Ingresos' es un collider en el camino 'Educación -> Ingresos <- Esfuerzo'.
- Condicionar en 'Ingresos' bloquea la dependencia entre 'Educación' y 'Esfuerzo'.
2. 'Oportunidades ⊥ Educación | Inteligencia':
- 'Inteligencia' es un nodo de fork en el camino 'Educación <- Inteligencia -> Oportunidades'.
- Condicionar en 'Inteligencia' bloquea el flujo de información entre 'Oportunidades' y 'Educación'.
3. 'Oportunidades ⊥ Esfuerzo | Ingresos, Inteligencia':
- Condicionar en 'Inteligencia' bloquea la influencia desde 'Oportunidades' a 'Ingresos'.
- Además, 'Ingresos' como collider bloquea el camino hacia 'Esfuerzo'.
")
# Para generar una visualización más detallada, exportar el gráfico a una imagen:
ggdag::ggdag(dag) +
ggtitle("Directed Acyclic Graph (DAG)") +
theme_dark()
# Cargar la librería
library(dagitty)
library(ggdag)
library(ggplot2)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
# Explicación de las independencias condicionales:
cat("
Explicación con d-separación:
1. 'Educación ⊥ Esfuerzo | Ingresos':
- 'Ingresos' es un collider en el camino 'Educación -> Ingresos <- Esfuerzo'.
- Condicionar en 'Ingresos' bloquea la dependencia entre 'Educación' y 'Esfuerzo'.
2. 'Oportunidades ⊥ Educación | Inteligencia':
- 'Inteligencia' es un nodo de fork en el camino 'Educación <- Inteligencia -> Oportunidades'.
- Condicionar en 'Inteligencia' bloquea el flujo de información entre 'Oportunidades' y 'Educación'.
3. 'Oportunidades ⊥ Esfuerzo | Ingresos, Inteligencia':
- Condicionar en 'Inteligencia' bloquea la influencia desde 'Oportunidades' a 'Ingresos'.
- Además, 'Ingresos' como collider bloquea el camino hacia 'Esfuerzo'.
")
# Para generar una visualización más detallada, exportar el gráfico a una imagen:
ggdag::ggdag(dag) +
ggtitle("Directed Acyclic Graph (DAG)") +
theme_dark()
# Cargar la librería
library(dagitty)
library(ggdag)
library(ggplot2)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
ggdag::ggdag(dag) +
ggtitle("Directed Acyclic Graph (DAG)") +
theme_dark()
# Cargar la librería
library(dagitty)
library(ggdag)
library(ggplot2)
# Crear la DAG
dag <- dagitty("
dag {
Inteligencia -> Educacion -> Ingresos
Inteligencia -> Oportunidades -> Ingresos
Esfuerzo -> Ingresos
}
")
ggdag::ggdag(dag) +
ggtitle("DAG") +
theme_dark()
